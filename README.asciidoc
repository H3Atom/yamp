= Yamp - Yet Another Macro Processor - for YAML
Peter Birch <birchb1024@gmail.com>
v0.1, 2019-01-01
:toc: macro
YAML is human friendly data serialization standard. footnote:[YAML stands for YAML Ain't Markup Language. See https://yaml.org/]  Yamp is a general-purpose macroprocessor for YAML files.  Both its input and output are YAML. It scans the input for symbols and makes substitutions and expansions on the output. yamp is 100% YAML so the syntax for defining and calling macros is YAML also.

.TL;DR - Input
[source, YAML]
----
- defmacro:
    name: foo
    args: [who]
    value:
        Hello: who
- foo:
    who: World
----

.Output
[source, YAML]
----
- Hello: World
----

== Get Started

Yamp is a Python 2.7 program contained in a single file. Assuming one has installed Python the program is run from the command-line giving the input file to parse as the first argument followed by optional arguments to the expansion. The expansion is written to the standard output:

.Usage
[source,bash]
----
$ python yamp.py <myinputfile>.yaml [arg1..argn]
----

== An example - Pipelines as Code.

Supposing we are building some https://github.com/tomzo/gocd-yaml-config-plugin[GoCD] pipeline definitions in YAML each of which uses the same Git repository.  The YAML we have to write looks like this:

.output.yaml
[source,YAML]
----
pipelines:
  mypipe1:
    group: mygroup
    label_template: ${COUNT}
    materials: # <1>
      mygit:
        branch: master
        git: http://my.example.org/mygit.git
    stages: null
  mypipe2:
    group: mygroup
    label_template: ${COUNT}
    materials: # <1>
      mygit:
        branch: ci
        git: http://my.example.org/mygit.git
    stages: null
----
<1> Duplicated

We don't want re-key duplicated code so we define a macro which yamp expands whenever it is invoked. Our yamp source code now looks like this:

.YAML source
[source,YAML]
----
define: # <1>
    name: mygit_repo_url
    value: http://my.example.org/mygit.git

defmacro: # <2>
    name: mygit_materials
    args: [branch_name]
    value:
      mygit:
        git: mygit_repo_url # <3>
        branch: branch_name
---
pipelines:
  mypipe1:
    group: mygroup
    label_template: "${COUNT}"
    materials: {mygit_materials: {branch_name: master}} # <4>
    stages:

  mypipe2:
    group: mygroup
    label_template: "${COUNT}"
    materials:
        mygit_materials:
            branch_name: ci # <5>
    stages:
----
<1> simple variable definition
<2> a macro Definition
<3> variable used
<4> a macro call - flow style
<5> a macro call - block style

When run through yamp, the output is as above. Now we have a single place where the git repository is defined, if we need to change it we can change it once.

== Applications

This program is general-purpose, it can be used wherever YAML is required. Its first uses were for GoCd pipelines and Ansible playbooks. These are human-readable source code which is a subset of YAML. Hence yamp may not be applied to all aspects of YAML especially those which result from data transmission.  We will not be attempting to exercise yamp with such inputs.

Since YAML is a superset of JSON it can also be used to generate JSON for, say, Azure ARM files.

== Similar Tools

There are many great general-purpose macro-processors available, starting with the venerable `GPM`, through `m4`, cpp, and lately, Jinja2. However these are predominantly character-based and the programmer has to compute the indentation required by YAML by counting spaces. Like previous authors we started on this course of writing yet another macro-processor primarily for reasons of laziness. Since yamp transforms maps and sequences not character strings, indentation is automatic.


== Reference

This section describes the operation of the processor and the macros available.

=== Processing

==== String interpolation

Inside strings, yamp will insert expansions delimited by the double-curlies `{{` and `}}`. It's looking for variable names.

[source, YAML]
----
- define: {name: X, value: Christopher}
- define: {name: AXA, value: 'A{{ X }}A'}
---
- AXA: Christopher
# Produces AChristopherA
----


=== Variables

During processing yamp maintains a hierarchy of bindings of variable names to variable values. The top level of bindings is the gobal environment, as each macro is applied the application creates a unique environment for the macro variables which is popped when the macro finishes.

==== `define` - Definition of Variables

You can define new variable bindings or update existing variables with the `define` macro. The value can be any YAML expansion. Variable names are expected to be strings.

[source, YAML]
----
- define: {name: age, value: 32}
- age
- define: {name: age2, value: [age, age]}
- age2
- define: {name: age2, value: [{define: {name: age, value: 99}}, age]}
- age2
# Produces:
#- 32
#- - 32
#  - 32
#- - 99
----

==== Scalars

Variables can contain any YAML scalar, int float, string, True, False and null.

==== Collections

Variables can contain any YAML collection ie, maps and lists.

==== Variable Expansion

When yamp scans YAML it looks for variables in the lists and map values. When one is found it is replaced with the current value of variable binding. It searches the stack of macro bindings until the global environment is reached. If no bindng is found the string is output unchanged.

===== Interpolation with dot syntax

If a potential variable contains periods, such as `data.height` the variable name is assumed to be the first item ie `data`. If a binding is found the value of the variable is assumed to be a collection and the sub-variable names are used to index the collection. The subvariable names are expanded. If the collection is a map, the sub-variable name is used as the key, if it is a list the subvariable must evaluate to an integer which is zero-indexed into the array.

[source, YAML]
----
- define:
    name: data
    value:
        - type: webserver
          hostname: web01
          ip: 1.1.2.3
        - type: database
          hostname: db01
          ip: 1.1.2.2
- data.1.hostname
# produces
- db01
----

==== Macros

===== Defining with `defmacro`

Macros are re-usable templates of YAML data that can be called up almost anywhere in the expansion. They differ from variables becuase they have parameters which are used to fill holes in the template. The are similar to functions, but unlike functions their entire text is always the result. By defining oft-repeated YAML fragments in macros repetitive work is avoided. Also a singular macro definition makes maintainance easy since there is a single defintion for a concept which canm be easily changed.

Macros are defined with the `define` macro which gives the macro a name and sepcifies the arguments it has and the expansion to return, the body.  A macro defintion looks like this:

[source,YAML]
----
- defmacro:
    name: <the name of the macro>
    args: [<list of argument names>, ...]
    value:
      <Some YAML to be expanded>
----

Example - Database upgrade steps:

[source,YAML]
----
defmacro:
  name: app-upgrade
  args: [appname, dbname]
  value:
      Database upgrade:
        - stop application {{ appname }}
        - backup app database {{ dbname }}
        - upgrade the database {{ dbname }}
        - restart the application {{ appname }}
        - smoke test {{ appname }}
---
- {app-upgrade: { appname: Netflix, dbname: db8812}}
- app-upgrade:
    appname: Netflix
    dbname: postgres123123
----

Produces:

[source,YAML]
----
- Database upgrade:
  - stop application Netflix
  - backup app datbase db8812
  - upgrade the database db8812
  - restart the application Netflix
  - smoke test Netflix
- Database upgrade:
  - stop application Netflix
  - backup app datbase postgres123123
  - upgrade the database postgres123123
  - restart the application Netflix
  - smoke test Netflix
----

==== Invoking/calling Macros

[source, YAML]
----
<macro name>: 
   <arg1> : <arg 1 value>
   ...
   <argN> : <arg N value>
----

==== Macros with variable arguments

If the args are speficied as a string, all the actual arguments are passed in as a map.

[source,YAML]
----
- defmacro:
    name: <the name of the macro>
    args: <argument variable name>
    value:
      <Some YAML to be expanded>
----

Example:

[source,YAML]
----
- defmacro:
    name: package
    args: all
    value:
      name: all.doc
      yum:
        name: apache
        state: all.state

---
package:
  doc: Install apache
  name: httpd
  state: latest
----

=== Conditional Expansion with `if then else`

.

=== Testing equality with `==`

.

=== Looping with `repeat`

.

=== Arithmetic with `+`

.

=== Reading files with `include`

[source, YAML]
----
include:
- <filename>
- <filename>
----

=== Reading data files with `load`

.

=== Evaluating Python expressions

[source, YAML]
----
- {python: ' 2**10 '}
# Produces
- 1024
----



=== Builtin Variables

==== `__FILE__` - the current source filename

==== `__parent__` - the environment binding parent

==== `env` - process environment

==== `argv` - command line arguments


