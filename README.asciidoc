= Yamp - Yet Another Macro Processor - for YAML
Peter Birch <birchb1024@gmail.com>
v0.1, 2019-01-26
:toc: macro
YAML is human friendly data serialization standard. footnote:[YAML stands for YAML Ain't Markup Language. See https://yaml.org/]  Yamp is a general-purpose macroprocessor for YAML files.  Both its input and output are YAML. It scans the input for symbols and makes substitutions and expansions on the output. yamp is 100% YAML so the syntax for defining and calling macros is YAML also.

== TL;DR

.Input
[source, YAML]
----
- defmacro:
    name: foo
    args: [who]
    value:
        Hello: who
- foo:
    who: World
----

.Output
[source, YAML]
----
- Hello: World
----

== Get Started

Yamp is a Python 2.7 program contained in a single file. Hence one has to install https://www.python.org/:[Python] and the https://pypi.org/project/PyYAML/:[pyyaml] module.

* First obtain a copy of the Yamp program. If you're reading this you probably did this already!

* Install Python 2.7 footnote:[This is for RedHat Linux.] : `$ sudo yum install -y python2`

* Then install the Python YAML module: `$ pip install pyyaml`

The program  is run from the command-line giving the input file to parse as the first argument followed by optional arguments to the expansion. The expansion is written to the standard output, which you normally redirect to another file.:

.Usage
[source,bash]
----
$ python yamp.py <myinputfile>.yaml [arg1..argn]
----

== An example - Pipelines as Code.

Supposing we are building some https://github.com/tomzo/gocd-yaml-config-plugin[GoCD] pipeline definitions in YAML each of which uses the same Git repository.  The YAML we have to write looks like this:

.output.yaml
[source,YAML]
----
pipelines:
  mypipe1:
    group: mygroup
    label_template: ${COUNT}
    materials: # <1>
      mygit:
        branch: master
        git: http://my.example.org/mygit.git
    stages: null
  mypipe2:
    group: mygroup
    label_template: ${COUNT}
    materials: # <1>
      mygit:
        branch: ci
        git: http://my.example.org/mygit.git
    stages: null
----
<1> Duplicated

We don't want re-key duplicated code so we define a macro which yamp expands whenever it is invoked. Our yamp source code now looks like this:

.YAML source
[source,YAML]
----
define: # <1>
    name: mygit_repo_url
    value: http://my.example.org/mygit.git

defmacro: # <2>
    name: mygit_materials
    args: [branch_name]
    value:
      mygit:
        git: mygit_repo_url # <3>
        branch: branch_name
---
pipelines:
  mypipe1:
    group: mygroup
    label_template: "${COUNT}"
    materials: {mygit_materials: {branch_name: master}} # <4>
    stages:

  mypipe2:
    group: mygroup
    label_template: "${COUNT}"
    materials:
        mygit_materials:
            branch_name: ci # <5>
    stages:
----
<1> simple variable definition
<2> a macro Definition
<3> variable used
<4> a macro call - flow style
<5> a macro call - block style

When run through yamp, the output is as above. Now we have a single place where the git repository is defined, if we need to change it we can change it once.

== Applications

This program is general-purpose, it can be used wherever YAML is required. Its first uses were for GoCd pipelines and Ansible playbooks. These are human-readable source code which is a subset of YAML. Hence yamp may not be applied to all aspects of YAML especially those which result from data transmission.  We will not be attempting to exercise yamp with such inputs.

Since YAML is a superset of JSON it can also be used to generate JSON for, say, Azure ARM files.

== Similar Tools

There are many great general-purpose macro-processors available, starting with the venerable `GPM`, through `m4`, cpp, and lately, Jinja2. However these are predominantly character-based and the programmer has to compute the indentation required by YAML by counting spaces. Like previous authors we started on this course of writing yet another macro-processor primarily for reasons of laziness. Since yamp transforms maps and sequences not character strings, indentation is automatic.


== Reference

This section describes the operation of the processor and the macros available.

=== Processing


When Yamp starts, it collects the command-line arguments and assigns the list to the variable `argv`. It collects the process environment and assigns it to the map variable `env`. Yamp then reads the input file, attempts to parse the YAML and holds the resulting data as objects in memory. (If the YAML does not parse Yamp exits). It recursively scans the objects looking for strings which are the same as defined variables or which contain variables inside the string in curly braces. If it finds a match, it substitutes the object with the variable's value.

Yamp is a substitution engine. It looks for things in it's input an when it sees them replaces them with the substitution. The things to look for and the substitutions we call variables and bindings. For example:

.Variables Bindings
[options="header,footer",width="50%"]
|=======================
|Variable Name|Value to substitute
|mygit_repo_url

a|
[source,YAML]
----
http://my.example.org/mygit.git
----

|mygit_materials

a|
[source,YAML]
----
args: [branch_name]
mygit:
        git: mygit_repo_url
        branch: branch_name
----

|=======================


When scanning maps, Yamp only substitutes variables for map keys which have embedded curly braces. 

Some special variables contain 'macros' - these must be within a map of their own, with a value containing a map of arguments which can contain anything. Normally a macro will contain more than the original, so we call this 'macro expansion' footnote:[But it could actually be a reduction!] ;-). 

Yamp is looking for macro calls with this structure:

[source,YAML]
----
<Macro>:
   <Argument>: <value>
   <Argument>: <value>
    . . .
----

Some macros have special functions and are built-in to Yamp. Those are describe in thie reference section.

Here's examples of three kinds of things Yamp is scanning for replacement:

.Simple Variables
[source,YAML]
----
- Username
- 'directory'
----

.Embeded Variables
[source,YAML]
----
- 'The username is {{Username}}'
----

.Macro Calls
[source,YAML]
----
- add_user:
    name: Kevin
    phone: (555) 098 880
----

When all the objects in the data have been scanned and in some cases, substituted, Yamp outputs the new object tree on the standard output in YAML format. Becuase YAML maps are unordered, the order of the keys and their corresponding values on output maybe be different from the input footnote:[Order-preservation may happen in a future version, but it's complicated].




=== Variables

During processing yamp maintains a hierarchy of bindings of variable names to variable values. The top level of bindings is the gobal environment, as each macro is applied the application creates a unique environment for the macro variables which is popped when the macro finishes.

==== `define` - Definition of Variables

You can define new variable bindings or update existing variables with the `define` macro. The value can be any YAML expansion. Variable names are expected to be strings.

[source, YAML]
----
- define: {name: age, value: 32}
- age
- define: {name: age2, value: [age, age]}
- age2
- define: {name: age2, value: [{define: {name: age, value: 99}}, age]}
- age2
# Produces:
#- 32
#- - 32
#  - 32
#- - 99
----

==== Scalars

Variables can contain any YAML scalar, int float, string, True, False and null.

==== Collections

Variables can contain any YAML collection ie, maps and lists.

==== Variable Expansion

When yamp scans YAML it looks for variables in the lists and map values. When one is found it is replaced with the current value of variable binding. It searches the stack of macro bindings until the global environment is reached. If no bindng is found the string is output unchanged.

===== Variables Embedded in Strings

Inside strings, yamp will insert expansions delimited by the double-curlies `{{` and `}}`. It's looking for variable names.

[source, YAML]
----
- define: {name: X, value: Christopher}
- define: {name: AXA, value: 'A{{ X }}A'}
---
- AXA
# Produces AChristopherA
----

===== Interpolation with dot syntax

If a potential variable contains periods, such as `data.height` the variable name is assumed to be the first item ie `data`. If a binding is found the value of the variable is assumed to be a collection and the sub-variable names are used to index the collection. The subvariable names are expanded. If the collection is a map, the sub-variable name is used as the key, if it is a list the subvariable must evaluate to an integer which is zero-indexed into the array.

[source, YAML]
----
- define:
    name: data
    value:
        - type: webserver
          hostname: web01
          ip: 1.1.2.3
        - type: database
          hostname: db01
          ip: 1.1.2.2
- data.1.hostname
# produces
- db01
----

===== Defining Multiple Variables

Declarations don't need the 'name' and 'value' keys, and multiple variables are simultaneously bound.

[source,YAML]
----
- define: { quick: 'shorthand' }
- define:
    name: Sara
    age: 34
    height: 123
----


==== Macros

Macros are re-usable templates of YAML objects that can be called up almost anywhere in the expansion. They differ from variables becuase they have parameters which are used to fill holes in the template. The are similar to functions, but unlike functions their entire text is always the result. By defining oft-repeated YAML fragments in macros repetitive work is avoided. Also a singular macro definition makes maintainance easy since there is a single defintion for a concept which canm be easily changed.

===== Defining with `defmacro`

Macros are defined with the `define` macro which gives the macro a name and sepcifies the arguments it has and the expansion to return, the body.  A macro defintion looks like this:

[source,YAML]
----
- defmacro:
    name: <the name of the macro>
    args: [<list of argument names>, ...]
    value:
      <Some YAML to be expanded>
----

Example - Database upgrade steps:

[source,YAML]
----
defmacro:
  name: app-upgrade
  args: [appname, dbname]
  value:
      Database upgrade for {{ appname }}:
        - stop application {{ appname }}
        - backup app database {{ dbname }}
        - upgrade the database {{ dbname }}
        - restart the application {{ appname }}
        - smoke test {{ appname }}
---
- {app-upgrade: { appname: Netflix, dbname: db8812}}
- app-upgrade:
    appname: Stan
    dbname: postgres123123
----

Produces:

[source,YAML]
----
- Database upgrade for Netflix:
  - stop application Netflix
  - backup app database db8812
  - upgrade the database db8812
  - restart the application Netflix
  - smoke test Netflix
- Database upgrade for Stan:
  - stop application Stan
  - backup app database postgres123123
  - upgrade the database postgres123123
  - restart the application Stan
  - smoke test Stan
----

==== Invoking/calling Macros

As above, macro calls are just maps with a particular structure:
[source, YAML]
----
<macro name>: 
   <arg1> : <arg 1 value>
   ...
   <argN> : <arg N value>
----

==== Macros with variable arguments

If the arguments in the definition are specified as a string, not a list, the string is the single argument. All the actual arguments at call-time are collected and bound to the variable in a map.

[source,YAML]
----
- defmacro:
    name: <the name of the macro>
    args: <argument_variable_name>
    value:
      <Some YAML to be expanded>
----

Example:

[source,YAML]
----
# Definition
- defmacro:
    name: package
    args: all
    value:
      name: all.doc
      yum:
        name: apache
        state: all.state

---
# Call
package:
  doc: Install apache
  name: httpd
  state: latest
----

Produces

[source,YAML]
----
name: Install apache
yum:
  name: apache
  state: latest
----

==== Nesting Macros

Macro calls can be nested i.e. a macro can can contain a call to another in its arguments. Likewise macro definitions can be nested. The macro arguments are lexically scoped, a closure is collected at the time of definition. The macro call executes in the environment in the define-time closure. Macros can call themselves directly or indirectly.



=== Conditional Expansion with `if then else`

The `if` macro renders one value from a choice of two based on whether the condition argument is true. Where true means it's `true` or not `false` or `null`. The `then` argument is expanded if so, otherwise the `else` argument. It's not required to have both `then` and `else` arguments - when the condition requires the missing one, it expands to `null`.

[source,YAML]
----
if: <Booleanish (true, false or null)>
then: <value if true>
else: <value if false or null>
----

Example:

[source,YAML]
----
# Some variable
define:
  application:
    name: CSIRAC
    has_database: true
    arch: valves
---
if: application.has_database
then:
  - shutdown database
else:
  - shutdown not required
----

Produces:

[source,YAML]
----
- shutdown database
----

Example - short form

[source,YAML]
----
if: true
else: 'This value if false or Null'
----

Produces `null`

=== Testing equality with `==`

Macro expands to `true` or `false` if the items in the list are equal.

[source,YAML]
----
{ ==: [arg1, arg2, ...] }
----

Example:

[source,YAML]
----
{ ==: [1, 1, 10] }
----

Produces the value `false`.


=== Looping with `repeat`

This macro repeatedly expands the same object over and over, either returning a list or a map. If the `key` argument is present it returns a map, using the `key` argument as the item's key. This must have embedded variables derived from the looping execution otherwise there will be a key collision error.

[source,YAML]
----
repeat:
  for: <loop variable name>
  in: [list of items]
  # Optionally:
  key: <string key with embedded varaibles in {{}}>
  body: <any value>
----


Example - returning a dictionary:

[source,YAML]
----
repeat:
  for: environment_name
  in:
    - DEV1
    - SVT
    - PROD
  key: 'Deploy_App_{{environment_name}}'
  body:
    stage: step
----

Produces:

[source,YAML]
----
Deploy_App_DEV1:
  stage: step
Deploy_App_PROD:
  stage: step
Deploy_App_SVT:
  stage: step
----

Example - returning a list:

[source,YAML]
----
repeat:
  for: loop_variable
  in: {range: [1,3]}
  body:
    loop_variable: 'KEY_{{loop_variable}}'
    some: step
    another:
----

Produces:

[source,YAML]
----
- another: null
  loop_variable: KEY_1
  some: step
- another: null
  loop_variable: KEY_2
  some: step
- another: null
  loop_variable: KEY_3
  some: step
----

=== Looping with `range`

The `range` macro substitutes a list of numbers that can be used in `repeat` macros. (Or anywhere else a list of numbers is needed). It generates them from the `start` an `end` arguemtents.

[source, YAML]
----
range: [3,5]
----

Produces `[3,4,5]`

=== Combining Lists with `flatten`

Sometimes you need to combine lists, perhaps from different macro expansions. The `flatten` macro combines multiple lists into a single, flat, list. The flattening is recursive. Syntax:

[source,YAML]
----
flatten: < list of objects >
----

For example:

[source,YAML]
----
define: {home-directories: [/home/elvis, /home/madonna]}
---
flatten: [[home-directories], /var, /log]
----

Produces:

[source,YAML]
----
- /home/elvis
- /home/madonna
- /var
- /log
----

=== Combining Maps with `merge`

The `merge` macro takes a list of maps and merges them togther to make a single map. When there are keys shared between the supplied maps, the program uses the last on seen, it over-writes the earlier value. Hence the order in the list dictates the priority. Syntax:

[source,YAML]
----
merge: < list of maps >
----

For example:

[source,YAML]
----
merge:
  - { a : 1 }
  - { b : 2 }
  - { c : 3 , a : -1}
----

Produces:

[source,YAML]
----
a: -1
b: 2
c: 3
----

A more complex example shows combining data from multiple sources:

[source,YAML]
----
- define:
    network-data:
      hostname: tetris.games.org
- defmacro:
    name: mymacro
    args: [arg1]
    value:
      hostname: arg1
      ip: 1.1.1.1
      app: tetris
- merge:
  - { hostname: tetris.home.org }
  - { site: Kansas }
  - mymacro:
      arg1: tetris
  - network-data
----

Which boils down to:

[source,YAML]
----
- app: tetris
  hostname: tetris.games.org
  ip: 1.1.1.1
  site: Kansas
----

=== Arithmetic with `+`

Add a list of numbers, int or float.

[source, YAML]
----
+: [1,2,4,8]
----

Produces `15`

=== Reading files with `include`

Reads and expands the list of Yamp YAML files in order.

[source, YAML]
----
include:
- <filename>
- <filename>
----

=== Reading data files with `load`

Read a single file of ordinary YAML data and returns the result in a list, one object for each 'doc'.

[source, YAML]
----
{load: <filename>}
----

=== Evaluating Python expressions

This macro allows you to execute expressions inside the Python interpreter running Yamp. Yamp uses the Python `eval()` function, passing the current variable bindings to eval as the `locals`. This allows Python to access the Yamp-defined variables. Python cannot see bindings in the environment hierarchy directly, so to resolve variables in higher environments use the Yamp lookup function as in `lookup(__parent__, 'variablename')[0]`` function. Warning - Yamp internals can change at any time.  

[source, YAML]
----
define: {FOO: 2}
---
python: ' FOO**10 '
----

Produces `1024`

This macro is recommended for simple tasks about objects such as:

* getting the length of a list,
* converting the case of a string
* getting the time

Examples:

[source, YAML]
----
- python: 'len(argv)'

- python: 'env["USERNAME"].upper()' 

- python: 'datetime.datetime.now()'

- python: 'lookup(__parent__, "argv")[0][0]' # ==> yamp.py

- python: 'iter(_ for _ in ()).throw(Exception("{} This is how to raise an exception!".format(env["USERNAME"])))'
----


=== Builtin Variables

Yamp automatically populates some variables as it executes. These are they:

* `__FILE__` - the current source filename

* `__parent__` - the current macro application's parent environment

* `env` - the process environment

* `argv` - the command line arguments

== Using Yamp as a Python Module

Maybe later...

== Maintenance of Yamp

=== Code
Run the unit tests with `python test/test_expand_01.py`. 

=== Updating This Document

This document is in http://www.methods.co.nz/asciidoc/:[AsciiDoc] format. Use the Linux Asciidoc packages. To Highlight the YAML syntax also install source-highlight and the https://gist.github.com/zeroyonichihachi/c4952b355bb7a27552a5f23e0c53b65f#file-yaml-lang:[YAML syntax module]. Save the HTML version in `doc/README.html`.
